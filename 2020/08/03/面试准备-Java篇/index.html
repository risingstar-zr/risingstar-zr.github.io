<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,算法,2021秋招,redis," />










<meta name="description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;整理一下Java篇会问到的一些知识点，学习过程中如有错误，欢迎私聊我纠正。 面试准备–Java篇threadlocal原理它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作的自己本地内存里面的变量，从而避免了线程安全问题，创建一个Thr">
<meta name="keywords" content="Java,算法,2021秋招,redis">
<meta property="og:type" content="article">
<meta property="og:title" content="面试准备-Java篇">
<meta property="og:url" content="http://risingstar-zr.github.io/2020/08/03/面试准备-Java篇/index.html">
<meta property="og:site_name" content="risingstar-zr的博客">
<meta property="og:description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;整理一下Java篇会问到的一些知识点，学习过程中如有错误，欢迎私聊我纠正。 面试准备–Java篇threadlocal原理它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作的自己本地内存里面的变量，从而避免了线程安全问题，创建一个Thr">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-08-26T11:43:54.746Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试准备-Java篇">
<meta name="twitter:description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;整理一下Java篇会问到的一些知识点，学习过程中如有错误，欢迎私聊我纠正。 面试准备–Java篇threadlocal原理它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作的自己本地内存里面的变量，从而避免了线程安全问题，创建一个Thr">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://risingstar-zr.github.io/2020/08/03/面试准备-Java篇/"/>





  <title>面试准备-Java篇 | risingstar-zr的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">risingstar-zr的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/about.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://risingstar-zr.github.io/2020/08/03/面试准备-Java篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="risingstar-zr">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="risingstar-zr的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试准备-Java篇</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-03T10:37:00+08:00">
                2020-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/面试准备/" itemprop="url" rel="index">
                    <span itemprop="name">面试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,579
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  27
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&nbsp;&nbsp;&nbsp;&nbsp;整理一下Java篇会问到的一些知识点，学习过程中如有错误，欢迎私聊我纠正。</p>
<h3 id="面试准备–Java篇"><a href="#面试准备–Java篇" class="headerlink" title="面试准备–Java篇"></a>面试准备–Java篇</h3><h4 id="threadlocal原理"><a href="#threadlocal原理" class="headerlink" title="threadlocal原理"></a>threadlocal原理</h4><p>它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作的自己本地内存里面的变量，从而避免了线程安全问题，创建一个ThreadLocal变量后每个线程会拷贝一个变量到自己本地内存。<br>使用场景：<br>（1）每个线程需要有自己单独的实例；<br>（2）实例需要在多个方法中共享，但不希望被多线程共享；<br>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p>
<h4 id="Object类里面的方法"><a href="#Object类里面的方法" class="headerlink" title="Object类里面的方法"></a>Object类里面的方法</h4><p>equals()方法：Object 类中的 equals 方法,equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性。<br>notify()和wait()方法区别：<br>前提：由同一个lock对象调用wait、notify方法。<br>1、当线程A执行wait方法时，该线程会被挂起；<br>2、当线程B执行notify方法时，会唤醒一个被挂起的线程A；<br>lock对象、线程A和线程B三者是一种什么关系？根据上面的结论，可以想象一个场景：<br>1、lock对象维护了一个等待队列list；<br>2、线程A中执行lock的wait方法，把线程A保存到list中；<br>3、线程B中执行lock的notify方法，从等待队列中取出线程A继续执行；</p>
<h4 id="wait-yield-和sleep-方法区别："><a href="#wait-yield-和sleep-方法区别：" class="headerlink" title="wait() yield()和sleep()方法区别："></a>wait() yield()和sleep()方法区别：</h4><p>yield()：让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。<br>sleep()：不释放任何锁，但是它过了睡眠时间后，不一定能获得执行的时间。<br>wait()：object对象中的方法，需在加锁的线程中执行此方法，它释放对象上的锁，以便另一个线程可以跳入并获取锁。待 notify() 或 notifyAll()方法对其唤醒！如果直接调用 wait()方法 会抛出 java.lang.IllegalMonitorStateException 异常  </p>
<h4 id="equals-和-的区别"><a href="#equals-和-的区别" class="headerlink" title="equals 和 == 的区别"></a>equals 和 == 的区别</h4><p>（1）equals 是方法，而 == 是操作符；<br>（2）对于基本类型的变量来说（如 short、 int、 long、 float、 double），只能使用 == ，因为这些基本类型的变量没有 equals 方法。对于基本类型变量的比较，使用 == 比较， 一般比较的是它们的值。<br>（3）对于引用类型的变量来说（例如 String 类）才有 equals 方法，因为 String 继承了 Object 类， equals 是 Object 类的通用方法。对于该类型对象的比较，默认情况下，也就是没有复写 Object 类的 equals 方法，使用 == 和 equals 比较是一样效果的，都是比较的是它们在内存中的存放地址。但是对于某些类来说，为了满足自身业务需求，可能存在 equals 方法被复写的情况，这时使用 equals 方法比较需要看具体的情况，例如 String 类，使用 equals 方法会比较它们的值；<br>转至：<a href="https://www.jianshu.com/p/9cbed9f33a4d" target="_blank" rel="noopener">https://www.jianshu.com/p/9cbed9f33a4d</a></p>
<h4 id="Java中存在无符号类型吗？如果有无符号类型，怎么处理？"><a href="#Java中存在无符号类型吗？如果有无符号类型，怎么处理？" class="headerlink" title="Java中存在无符号类型吗？如果有无符号类型，怎么处理？"></a>Java中存在无符号类型吗？如果有无符号类型，怎么处理？</h4><p>Java不支持无符号数据类型。byte，short，int和long都是有符号数据类型。对于有符号数据类型，值范围的一半存储正数，一半用于负数，因为一个位用于存储有符号值的符号。<br>Java在包装器类中有一些静态方法，以支持处理带符号值中的位的操作，就像它们是无符号整数一样。<br>例如，对于输入-10，返回的值将是2^8 +(-10),也就是246。负数以2的补码形式存储。 值-10将被存储为11110110。最高有效位1表示它是一个负数。<br>前7位(1110110)的2的补码是001010，十进制为10。<br>如果考虑实际位11110110，在一个字节中作为无符号整数，其值为246(128 + 64 + 32 + 16 + 0 + 4 + 2 + 0)。  </p>
<h4 id="Java抽象类和接口的区别"><a href="#Java抽象类和接口的区别" class="headerlink" title="Java抽象类和接口的区别"></a>Java抽象类和接口的区别</h4><p>1）抽象类可以有默认的方法实现完全是抽象的，接口根本不存在方法的实现；<br>2）抽象类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现；<br>3）抽象类可以有构造器，而接口不能有构造器；<br>4）抽象方法可以有public、protected和default这些修饰符；接口默认修饰符是public，不可以使用其它修饰符；<br>5）抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。<br>6）如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。</p>
<h4 id="Java封装类"><a href="#Java封装类" class="headerlink" title="Java封装类"></a>Java封装类</h4><p>封装的优点：<br>（1）良好的封装能够减少耦合；<br>（2）类内部的结构可以自由修改；<br>（3）可以对成员变量进行更精确的控制；<br>（4）隐藏信息，实现细节；   </p>
<h4 id="Java多态"><a href="#Java多态" class="headerlink" title="Java多态"></a>Java多态</h4><p>（1）继承；（2）重写；（3）父类引用指向子类对象；<br>多态优点：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。<br>多态的实现方式：<br>（1）重写：这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。<br>（2）接口：生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。<br>（3）抽象类和抽象方法</p>
<h4 id="多线程是什么？多线程会出现什么问题？你的理解？"><a href="#多线程是什么？多线程会出现什么问题？你的理解？" class="headerlink" title="多线程是什么？多线程会出现什么问题？你的理解？"></a>多线程是什么？多线程会出现什么问题？你的理解？</h4><p>多线程：多个线程并发执行的过程。<br>并发问题（安全性问题）：<br>(1)Java 内存模型规定了所有的变量都存储在主内存中，每条线程有自己的工作内存；<br>(2)线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。<br>(3)线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。<br>(4)不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。<br>原子性，即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>可见性，当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>有序性，有序性指的是数据不相关的变量在并发的情况下，实际执行的结果和单线程的执行结果是一样的，不会因为重排序的问题导致结果不可预知。</p>
<h4 id="线程几种实现方式，状态转换，ThreadPoolExecutor参数解析，执行流程"><a href="#线程几种实现方式，状态转换，ThreadPoolExecutor参数解析，执行流程" class="headerlink" title="线程几种实现方式，状态转换，ThreadPoolExecutor参数解析，执行流程"></a>线程几种实现方式，状态转换，ThreadPoolExecutor参数解析，执行流程</h4><p><strong>实现方式</strong>：（1）继承Thread 重写run方法，实例化一个对象，调用start（）；<br>（2）实现Runable接口，如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口。<br>（3）实现Callable接口通过FutureTask包装器来创建Thread线程；<br>（4）使用ExecutorService、Callable、Future实现有返回结果的线程<br><strong>Java线程五种状态</strong>：新建状态，可运行，运行，死亡，阻塞；<br><strong>新建状态</strong>：新建一个线程对象，在没有调用start()方法之前；<br><strong>可运行</strong>（就绪状态）：就绪状态，调用start()方法之后进入就绪状态， 但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权；<br><strong>运行(RUNNING)</strong>：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态。<br><strong>阻塞状态</strong>：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态。<br>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。<br>(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。<br>(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。<br>join()方法解释：join()方法只会使主线程进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。<br>PS:join源码中，只会调用wait方法，并没有在结束时调用notify，这是因为线程在die的时候会自动调用自身的notifyAll方法，来释放所有的资源和锁。<br><strong>死亡状态</strong>：线程执行结束，线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。<br><strong>ThreadPoolExecutor参数解析</strong>：ThreadPoolExecutor是一个非常重要的类,用来构建带有线程池的任务执行器，通过配置不同的参数来构造具有不同规格线程池的任务执行器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure></p>
<p>corePoolSize核心线程数、maximumPoolSize最大线程数、keepAliveTime线程执行完后空闲的存活时间、workQueue任务队列、ThreadFactory 创建线程的工厂，通过他可以创建线程时做一些想做的事，比如自定义线程名称、RejectedExecutionHandler 线程数和队列都满的情况下，对新添加的任务的处理方式。  </p>
<h4 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h4><p>AQS：维护了一个volatile语义(支持多线程下的可见性)的共享资源变量state和一个FIFO线程同步等待队列(多线程竞争state被阻塞时会进入此队列)。是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。<br>ReentrantLock的基本实现可以概括为：先通过CAS尝试获取锁。如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起。当锁被释放之后，排在CLH队列队首的线程会被唤醒，然后CAS再次尝试获取锁。在这个时候，如果：<br>非公平锁：如果同时还有另一个线程进来尝试获取，那么有可能会让这个线程抢先获取；<br>公平锁：如果同时还有另一个线程进来尝试获取，当它发现自己不是在队首的话，就会排到队尾，由队首的线程获取到锁。<br>可重入锁。可重入锁是指同一个线程可以多次获取同一把锁。ReentrantLock和synchronized都是可重入锁。<br>可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，而ReentrantLock则提供了中断功能。<br>公平锁与非公平锁。公平锁是指多个线程同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，而非公平锁则允许线程“插队”。synchronized是非公平锁，而ReentrantLock的默认实现是非公平锁，但是也可以设置为公平锁。<br>CAS操作(CompareAndSwap)。CAS操作简单的说就是比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。<br>以ReentrantLock为例,state可以用来表示该锁被线程重入的次数。当state为0表示该锁不被任何线程持有;当state为1表示线程恰好持有该锁1次(未重入);当state大于1则表示锁被线程重入state次。因为这是一个会被并发访问的量,为了防止出现可见性问题要用volatile进行修饰。</p>
<h4 id="什么情况下使用ReenTrantLock？"><a href="#什么情况下使用ReenTrantLock？" class="headerlink" title="什么情况下使用ReenTrantLock？"></a>什么情况下使用ReenTrantLock？</h4><p>需要实现ReenTrantLock的三个独有功能时：<br>(1)ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<br>(2)ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。<br>(3)ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</p>
<h4 id="ReenTrantLock和Synchronized区别？"><a href="#ReenTrantLock和Synchronized区别？" class="headerlink" title="ReenTrantLock和Synchronized区别？"></a>ReenTrantLock和Synchronized区别？</h4><p>（1）锁的实现：<br>Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。<br>（2）性能的区别：<br>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>
<h4 id="CPU突然飙升的过程？"><a href="#CPU突然飙升的过程？" class="headerlink" title="CPU突然飙升的过程？"></a>CPU突然飙升的过程？</h4><p>写起来思路很清晰，但实际上整个过程花费了大半天的时间，其实排查的过程中，有很多关键点没有抓到，有很多现象，是可以凭经验条件反射的推断出原因的：<br>（1）看到cpu使用率上涨，用jstack看使用cpu的线程，以及该线程在跑什么代码。<br>（2）找到是gc线程，然后看gc曲线是否正常。<br>（3）看堆内存曲线，正常的曲线是锯齿形的，如果不是，一次full GC之后内存没有明显下降，那基本可以推断发生内存泄漏了。<br>（4）怀疑是内存泄漏的问题，可以跑jmap，然后拉到MAT分析。<br>（5）第四步比较耗时的话，可以同时跑这个命令：jmap -histo pid。看看有没有线索。</p>
<h4 id="线程同步的方式？"><a href="#线程同步的方式？" class="headerlink" title="线程同步的方式？"></a>线程同步的方式？</h4><p>（1）Synchronized关键字修饰的同步方法；<br>（2）Synchronized修饰的同步代码块；<br>（3）使用特殊域变量（volatile）实现线程同步；<br>（4）ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。<br>ReenreantLock类的常用方法有：<br>ReentrantLock() : 创建一个ReentrantLock实例<br>lock() : 获得锁<br>unlock() : 释放锁<br>（5）使用局部变量实现线程同步，如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。<br>（6）使用阻塞队列实现线程同步，前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。 使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。 本小节主要是使用LinkedBlockingQueue<e>来实现线程的同步，LinkedBlockingQueue<e>是一个基于已连接节点的，范围任意的blocking queue。<br>队列是先进先出的顺序（FIFO），关于队列以后会详细讲解~<br>（7）使用原子变量实现线程同步原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作。即-这几种行为要么同时完成，要么都不完成。在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。</e></e></p>
<h4 id="有哪些具体的垃圾收集器？"><a href="#有哪些具体的垃圾收集器？" class="headerlink" title="有哪些具体的垃圾收集器？"></a>有哪些具体的垃圾收集器？</h4><p>（1）串行垃圾回收器（Serial）：为单线程环境设计，只使用一个线程进行垃圾回收，会暂停所有用户线程，不适合服务器环境；<br>（2）并行垃圾回收器（Patallel）：多个垃圾收集线程并发工作，用户状态为暂停状态，适用于科学计算、大数据<br>处理首台处理等弱交互场景；<br>（3）并发垃圾回收器（CMS）：用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程，适用对响应时间有要求的场景；<br>（4）G1垃圾回收器将堆内存分成不同的区域然后并发的对其进行垃圾回收；G1是一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现搞吞吐量的同时尽可能的满足垃圾收集暂停时间的要求另外它还具有一下的特性：<br>像CMS收集器一样，能与应用程序线程并发执行。<br>整理休闲空间更快。<br>需要更多的时间来预测GC停顿时间。<br>不希望牺牲大量的吞吐性能。<br>不需要更大的Java Heap.<br><a href="https://juejin.im/post/6844904000286883848" target="_blank" rel="noopener">https://juejin.im/post/6844904000286883848</a></p>
<h4 id="什么时候考虑把CMS换成G1或者这两个收集器各自适合在什么场景下？"><a href="#什么时候考虑把CMS换成G1或者这两个收集器各自适合在什么场景下？" class="headerlink" title="什么时候考虑把CMS换成G1或者这两个收集器各自适合在什么场景下？"></a>什么时候考虑把CMS换成G1或者这两个收集器各自适合在什么场景下？</h4><p>CMS（年老代-并行-收集器）获取最短回收停顿时间为目标的收集器。比较适合互联网响应式应用场景，采用的是<strong>“标记-清除”</strong>算法。<br>G1（Garbage First）是目前最为前沿的垃圾回收器，在前面的内容中已经提过JDK1.8以后的生产实践新生代、年老代都可以采用G1作为垃圾回收器。其采用的收集算法是”标记-清除-整理“，所以不会产生内存碎片。<br>Parallel Scavenge （新生代-并行-收集器）采用的也是多线程，以及复制收集算法，与其他同类型收集器不同的是，它的关注点是达到一个可控制吞吐量的目标，<strong><em>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾回收的时间)，</em></strong>假设虚拟机总共运行了100分钟，其中垃圾回收花了一分钟，那么吞吐量就是99%。高吞吐量的目的是为了高效的利用CPU时间，从而尽快的完成程序运算任务，主要适合后台运算不需要有太多交互的应用场景。<br>Parallel Old（年老代-并行-收集器）是Parallel Scavenge的老年代版本，是多线程，采用标记-整理算法的收集器。</p>
<h4 id="BIO-NIO-AIO区别"><a href="#BIO-NIO-AIO区别" class="headerlink" title="BIO/NIO/AIO区别"></a>BIO/NIO/AIO区别</h4><p>BIO：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。<br>NIO同步非阻塞的I/O模型，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。<br>（1）IO流是阻塞的，NIO流是不阻塞的；<br>（2）IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)；有数据都是用缓冲区处理的，包括读和写。最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。<br>（3）NIO 通过Channel（通道） 进行读写。通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。<br>（4）NIO有选择器，而IO没有。选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。<br>AIO：它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p>NIO适用场景：<br>服务器需要支持超大量的长时间连接。比如10000个连接以上，并且每个客户端并不会频繁地发送太多数据。例如总公司的一个中心服务器需要收集全国便利店各个收银机的交易信息，只需要少量线程按需处理维护的大量长期连接。</p>
<h4 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型(JMM)"></a>Java内存模型(JMM)</h4><p>JMM就是一组规则，这组规则意在解决在并发编程可能出现的线程安全问题，并提供了内置解决方案（happen-before原则）及其外部可使用的同步手段(synchronized/volatile等)，确保了程序执行在多线程环境中的应有的原子性，可视性及其有序性。</p>
<h4 id="Java浅谈AQS"><a href="#Java浅谈AQS" class="headerlink" title="Java浅谈AQS"></a>Java浅谈AQS</h4><p>所谓AQS，指的是AbstractQueuedSynchronizer，它提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的。AQS维护了一个volatile语义(支持多线程下的可见性)的共享资源变量state和一个FIFO线程等待队列(多线程竞争state被阻塞时会进入此队列)。<br>资源的共享方式分为两种：（1）独占式，只有单个线程能够成功获取资源并执行，如ReentrantLock。（2）共享式。多个线程可成功获取资源并执行，如Semaphore/CountDownLatch等。主要包括下面方法：<br>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
<h4 id="GC-Roots的对象"><a href="#GC-Roots的对象" class="headerlink" title="GC Roots的对象"></a>GC Roots的对象</h4><p>根搜索算法是JVM用来判断对象是否存活的算法，此算法基本思路为通过一系列的“GC Roots”对象作为起始点，从这些节点往下搜索，当一个对象和GC Roots不可达时，则该对象是无用的，可被回收。<br>可作为GC Roots的对象有：<br>1、虚拟机栈（栈帧中的本地变量表）中引用的对象；<br>2、方法区中类静态属性引用的对象；<br>3、方法区中常量引用的对象；<br>4、本地方法栈中JNI中引用的对象；</p>
<h4 id="线程逃逸问题"><a href="#线程逃逸问题" class="headerlink" title="线程逃逸问题"></a>线程逃逸问题</h4><p>this逃逸是指在构造函数返回之前其他线程就持有改对象的引用。条用尚未构造完全的对象可能引发令人疑惑的错误。因此应该避免逃逸的发生。<br>this逃逸经常发生在构造函数中启动线程或注册监听器时<br>解决办法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ThisEscape &#123;</span><br><span class="line">	private Thread t;</span><br><span class="line">	public <span class="function"><span class="title">ThisEscape</span></span>() &#123;</span><br><span class="line">		t = new Thread(new EscapeRunnable());</span><br><span class="line">		// ...其他代码</span><br><span class="line">	&#125;</span><br><span class="line">	public void <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;	</span><br><span class="line">	private class EscapeRunnable implements Runnable &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">			// 在这里通过ThisEscape.this就可以引用外围类对象, 此时可以保证外围类对象已经构造完成</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="多线程中lock和Synchronized的区别？"><a href="#多线程中lock和Synchronized的区别？" class="headerlink" title="多线程中lock和Synchronized的区别？"></a>多线程中lock和Synchronized的区别？</h4><p>synchronized是基于JVM实现的，内置锁，Java中的每一个对象都可以作为锁。对于同步方法，锁是当前实例对象。对于静态同步方法，锁是当前对象的Class对象。对于同步方法块，锁是Synchonized括号里配置的对象。Lock是基于在语言层面实现的锁，Lock锁可以被中断，支持定时锁。Lock可以提高多个线程进行读操作的效率。通过对比得知，Lock的效率是明显高于synchronized关键字的，一般对于数据结构设计或者框架的设计都倾向于使用Lock而非Synchronized。<br>Lock和Synchronized关键字的区别如下：<br>（1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；<br>（2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；<br>（3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；<br>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。<br>（4）Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）<br>性能上来说，在资源竞争不激烈的情形下，Lock性能稍微比synchronized差点（编译程序通常会尽可能的进行优化synchronized）。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。  </p>
<h4 id="Java中static、final、static-final的区别？"><a href="#Java中static、final、static-final的区别？" class="headerlink" title="Java中static、final、static final的区别？"></a>Java中static、final、static final的区别？</h4><p>static 修饰 属性，方法，代码段，内部类；在类初始化时加载，初始化后可以修改；static修饰的属性和方法跟具体对象无关；<br>final 修饰属性，方法和类；可以编译时或在运行时初始化，一旦初始化后就不可修改；<br>static final 修饰属性时表示一旦给值，就不可修改，并且可以通过类名访问；修饰方法时不可被重写，可以在不new 对象时调用；  </p>
<h4 id="Java类加载机制？"><a href="#Java类加载机制？" class="headerlink" title="Java类加载机制？"></a>Java类加载机制？</h4><h4 id="JDK-JRE区别？"><a href="#JDK-JRE区别？" class="headerlink" title="JDK JRE区别？"></a>JDK JRE区别？</h4><p>JDK主要包含三部分：<br>第一部分就是Java运行时环境，JVM。<br>第二部分就是Java的基础类库，这个类库的数量还是非常可观的。<br>第三部分就是Java的开发工具，它们都是辅助你更好的使用Java的利器。<br>下面是JDK附带的一些重要组件:<br>apt 注解处理工具<br>javadoc 文档生成器，可以自动从源代码生成说明文档<br>jar 归档器，将相关的类库打包到一个JAR文件中。还可以帮助管理JAR文件<br>jConsole Java监控和管理平台<br>jhat Java堆分析工具<br>jstack 打印Java线程的堆栈信息<br>keytool 策略创建和管理工具<br>jarsigner Java签名和验证工具<br>同JRE,JDK也依赖于平台，所以要下载与机器相对应的JDK包<br>只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。</p>
<h4 id="性能调优工具jmap"><a href="#性能调优工具jmap" class="headerlink" title="性能调优工具jmap"></a>性能调优工具jmap</h4><p>命令jmap是一个多功能的命令。它可以生成 java 程序的 dump 文件， 也可以查看堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有条不紊，勇往直前。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="risingstar-zr 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="risingstar-zr 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    risingstar-zr
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://risingstar-zr.github.io/2020/08/03/面试准备-Java篇/" title="面试准备-Java篇">http://risingstar-zr.github.io/2020/08/03/面试准备-Java篇/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="" rel="external nofollow" target="_blank"></a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
            <a href="/tags/2021秋招/" rel="tag"># 2021秋招</a>
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/03/面试准备-计算机网络篇/" rel="next" title="面试准备-计算机网络篇">
                <i class="fa fa-chevron-left"></i> 面试准备-计算机网络篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/03/2021正式批-顺丰一面面经/" rel="prev" title="2021正式批-顺丰一面面经">
                2021正式批-顺丰一面面经 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="risingstar-zr" />
            
              <p class="site-author-name" itemprop="name">risingstar-zr</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/risingstar-zr" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:dzxyzr@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/3905382923" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/risingstar-zr" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-zhihu"></i>知乎</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.cnblogs.com/andyxq/" title="Andyxq" target="_blank">Andyxq</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://zhoushengming.github.io/" title="xiaoming" target="_blank">xiaoming</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.yangyingming.com/" title="呓语 | 杨英明的个人博客" target="_blank">呓语 | 杨英明的个人博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="micookie.github.io" title="micookie" target="_blank">micookie</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#面试准备–Java篇"><span class="nav-number">1.</span> <span class="nav-text">面试准备–Java篇</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#threadlocal原理"><span class="nav-number">1.1.</span> <span class="nav-text">threadlocal原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object类里面的方法"><span class="nav-number">1.2.</span> <span class="nav-text">Object类里面的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-yield-和sleep-方法区别："><span class="nav-number">1.3.</span> <span class="nav-text">wait() yield()和sleep()方法区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals-和-的区别"><span class="nav-number">1.4.</span> <span class="nav-text">equals 和 == 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中存在无符号类型吗？如果有无符号类型，怎么处理？"><span class="nav-number">1.5.</span> <span class="nav-text">Java中存在无符号类型吗？如果有无符号类型，怎么处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java抽象类和接口的区别"><span class="nav-number">1.6.</span> <span class="nav-text">Java抽象类和接口的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java封装类"><span class="nav-number">1.7.</span> <span class="nav-text">Java封装类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java多态"><span class="nav-number">1.8.</span> <span class="nav-text">Java多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程是什么？多线程会出现什么问题？你的理解？"><span class="nav-number">1.9.</span> <span class="nav-text">多线程是什么？多线程会出现什么问题？你的理解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程几种实现方式，状态转换，ThreadPoolExecutor参数解析，执行流程"><span class="nav-number">1.10.</span> <span class="nav-text">线程几种实现方式，状态转换，ThreadPoolExecutor参数解析，执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock原理"><span class="nav-number">1.11.</span> <span class="nav-text">ReentrantLock原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么情况下使用ReenTrantLock？"><span class="nav-number">1.12.</span> <span class="nav-text">什么情况下使用ReenTrantLock？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReenTrantLock和Synchronized区别？"><span class="nav-number">1.13.</span> <span class="nav-text">ReenTrantLock和Synchronized区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU突然飙升的过程？"><span class="nav-number">1.14.</span> <span class="nav-text">CPU突然飙升的过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程同步的方式？"><span class="nav-number">1.15.</span> <span class="nav-text">线程同步的方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有哪些具体的垃圾收集器？"><span class="nav-number">1.16.</span> <span class="nav-text">有哪些具体的垃圾收集器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么时候考虑把CMS换成G1或者这两个收集器各自适合在什么场景下？"><span class="nav-number">1.17.</span> <span class="nav-text">什么时候考虑把CMS换成G1或者这两个收集器各自适合在什么场景下？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BIO-NIO-AIO区别"><span class="nav-number">1.18.</span> <span class="nav-text">BIO/NIO/AIO区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java内存模型-JMM"><span class="nav-number">1.19.</span> <span class="nav-text">Java内存模型(JMM)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java浅谈AQS"><span class="nav-number">1.20.</span> <span class="nav-text">Java浅谈AQS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC-Roots的对象"><span class="nav-number">1.21.</span> <span class="nav-text">GC Roots的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程逃逸问题"><span class="nav-number">1.22.</span> <span class="nav-text">线程逃逸问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程中lock和Synchronized的区别？"><span class="nav-number">1.23.</span> <span class="nav-text">多线程中lock和Synchronized的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java中static、final、static-final的区别？"><span class="nav-number">1.24.</span> <span class="nav-text">Java中static、final、static final的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java类加载机制？"><span class="nav-number">1.25.</span> <span class="nav-text">Java类加载机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-JRE区别？"><span class="nav-number">1.26.</span> <span class="nav-text">JDK JRE区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能调优工具jmap"><span class="nav-number">1.27.</span> <span class="nav-text">性能调优工具jmap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">risingstar-zr</span>

  
</div>


    <div class="powered-by">
        <i class="fa fa-user-md"></i>
        <span id="busuanzi_container_site_uv">本站访客数:
            <span id="busuanzi_value_site_uv"></span>
        </span>
    </div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">
	  <span>
	  	Hosted by <a href="http://risingstar.pw/" style="font-weight: bold">www.risingstar.pw</a>
	  </span>
  </div>





        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
